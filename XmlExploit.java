import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.ParserConfigurationException;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;


public class XmlExploit {

    // Info & code from: https://blog.pragmatists.com/xml-be-cautious-69a981fdc56a

    private static String readAllBytes(InputStream is) throws Exception {
        ByteArrayOutputStream result = new ByteArrayOutputStream();
        int bytesRead;
        byte[] buffer = new byte[1024];
        while ((bytesRead = is.read(buffer, 0, buffer.length)) != -1) {
            result.write(buffer, 0, bytesRead);
        }
        result.flush();
        return new String(result.toByteArray(), StandardCharsets.UTF_8);
    }

    private static Document parseXml(String content) throws Exception {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        return builder.parse(new ByteArrayInputStream(content.getBytes()));
    }

    /**
     * Code copied from owasp and slightly modified:
     * https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Prevention_Cheat_Sheet
     */
    private static Document parseXmlSecurely(String content) throws Exception {

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        String feature = null;
        try {
            // This is the PRIMARY defense. If DTDs (doctypes) are disallowed, almost all XML entity attacks are prevented
            // Xerces 2 only - http://xerces.apache.org/xerces2-j/features.html#disallow-doctype-decl
            feature = "http://apache.org/xml/features/disallow-doctype-decl";
            factory.setFeature(feature, true);
 
            // If you can't completely disable DTDs, then at least do the following:
            // Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-general-entities
            // Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-general-entities
            // JDK7+ - http://xml.org/sax/features/external-general-entities    
            feature = "http://xml.org/sax/features/external-general-entities";
            factory.setFeature(feature, false);
 
            // Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-parameter-entities
            // Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-parameter-entities
            // JDK7+ - http://xml.org/sax/features/external-parameter-entities    
            feature = "http://xml.org/sax/features/external-parameter-entities";
            factory.setFeature(feature, false);
      
            // Disable external DTDs as well
            feature = "http://apache.org/xml/features/nonvalidating/load-external-dtd";
            factory.setFeature(feature, false);
      
            // and these as well, per Timothy Morgan's 2014 paper: "XML Schema, DTD, and Entity Attacks"
            factory.setXIncludeAware(false);
            factory.setExpandEntityReferences(false);
       
            // And, per Timothy Morgan: "If for some reason support for inline DOCTYPEs are a requirement, then 
            // ensure the entity settings are disabled (as shown above) and beware that SSRF attacks
            // (http://cwe.mitre.org/data/definitions/918.html) and denial 
            // of service attacks (such as billion laughs or decompression bombs via "jar:") are a risk."
      
            // remaining parser logic
            DocumentBuilder builder = factory.newDocumentBuilder();
            return builder.parse(new ByteArrayInputStream(content.getBytes()));

        } catch (ParserConfigurationException e) {
            // This should catch a failed setFeature feature
            System.err.println("ParserConfigurationException was thrown. The feature '" + feature + "' is probably not supported by your XML processor.");
            throw e;
        } catch (SAXException e) {
            // On Apache, this should be thrown when disallowing DOCTYPE
            System.err.println("A DOCTYPE was passed into the XML document");
            throw e;
        } catch (IOException e) {
            // XXE that points to a file that doesn't exist
            System.err.println("IOException occurred, XXE may still possible: " + e.getMessage());
            throw e;
        }
    }

    private static void printXml(Document document) {
        StringBuilder sb = new StringBuilder("");
        NodeList contents = document.getChildNodes();
        for (int i = 0; i < contents.getLength(); i += 1) {
            Node content = contents.item(i);
            if ("content".equals(content.getNodeName())) {
                sb.append(content.getTextContent());
            }
        }
        String result = sb.toString();
        if (!result.isEmpty()) {
            System.out.println(result);
        }
        System.out.println("\nFinished processing xml\n");
    }

    private static final long BYTES_IN_KB = 1024;
    private static final long BYTES_IN_MB = BYTES_IN_KB * 1024;
    private static final long BYTES_IN_GB = BYTES_IN_MB * 1024;
    private static final String FORMAT_STR = "%.1f %s";

    private static String formatBytes(long bytes) {
        if (bytes < BYTES_IN_KB) {
            return bytes + " B";
        } else if (bytes < BYTES_IN_MB) {
            return String.format(FORMAT_STR, (double) bytes / BYTES_IN_KB, " KiB");
        } else if (bytes < BYTES_IN_GB) {
            return String.format(FORMAT_STR, (double) bytes / BYTES_IN_MB, " MiB");
        }
        return String.format(FORMAT_STR, (double) bytes / BYTES_IN_GB, " GiB");
    }

    private static long vmStats() {
        Runtime r = Runtime.getRuntime();
        long free = r.freeMemory();
        System.out.println("VM stats");
        System.out.println("  totalMem: " + formatBytes(r.totalMemory()));
        System.out.println("  maxMem: " + formatBytes(r.maxMemory()));
        System.out.println("  freeMem: " + formatBytes(free));
        return free;
    }

    public static void main(String[] args) throws Exception {
        long free;
        long diff;
        long temp;

        System.out.println("Before reading stdin");
        free = vmStats();
        System.out.println("  free-diff: N/A\n");

        String content = readAllBytes(System.in);

        System.out.println("After reading stdin");
        temp = vmStats();
        diff = free - temp;
        free = temp;
        System.out.println("  free-diff: " + formatBytes(diff) + "\n");

        Document document;

        if (args.length > 0 && "secure".equals(args[0])) {
            document = parseXmlSecurely(content);
        } else {
            document = parseXml(content);
        }

        System.out.println("After DOM parsing");
        temp = vmStats();
        diff = free - temp;
        System.out.println("  free-diff: " + formatBytes(diff) + "\n");

        printXml(document);
    }

}
